# 多线程 #
<hr>
## 多线程的概念 ##
多线程：程序中多个片断同时执行。  

通常，CPU在线程间的切换非常迅速，使人们感觉到好象所有线程是同时进行的。
## 实现方法 ##
* 必须实现Runnable接口
 * 间接实现：拓展Thread类，或者其它实现Runnable的类
 * 直接实现：实现Runnable接口
### Thread类介绍 ###
Thread类是java.lang包中的一个专门用来创建线程和对线程进行操作的类。

这些方法分为：  

* 构造方法
* run()方法
* 改变线程状态的方法
* 操作线程属性的方法
### 两种实现线程方式的对比 ###
扩展Thread的优点：
当一个run()方法体现在继承Thread类的类中，用this指向实际控制运行的Thread实例。因此，代码不再需要使用如下控制：

    Thread.currentThread().join();
而可以简单地用：

    join();
因为代码简单了一些，许多Java编程语言的程序员使用扩展Thread的机制。注意：如果你采用这种方法，在你的代码生命周期的后期，单继承模型可能会给你带来困难。

实现Runnable的优点:

从面向对象的角度来看，Thread类是一个虚拟处理机严格的封装，因此只有当处理机模型修改或扩展时，才应该继承类。正因为这个原因和区别一个正在运行的线程的处理机、代码和数据部分的意义。

由于**Java技术只允许单一继承**，所以如果你已经继承了Thread，你就不能再继承其它任何类，例如Applet。在某些情况下，这会使你只能采用实现Runnable的方法。

因为有时你必须实现Runnable，所以你可能喜欢保持一致，并总是使用这种方法。
## 线程的启动 ##
一个个新创建的线程并不自动开始运行。你必须调用它的**start()方法**。

调用start()方法使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。

**不要直接调用run（）方法**。  
区别：普通方法调用，启动线程。
### 线程运行 ###
尽管线程变为可运行的，但它并不立即运行。在一个只有一个处理器的的机器上，在一个时刻值只能进行一个动作。  
在Java中，**线程是抢占式的**，但并不一定是分时的（一个常见的错误是认为“抢占式”只不过是“分时”的一种新奇的称呼）。 
抢占式调度模型是指可能有多个程序时可运行的，但只有一个程序在实际运行。这个线程会一直运行，直至它不再是可运行的，或者另一个具有更高优先级的线程成为可运行的。对于后一种情况，低优先级程序被高优先级程序抢占了运行的机会。  
一个线程可能因为各种原因而不再是可运行的。线程的方法可能执行了一个Thread.sleep()调用，要求这个线程暂停一段时间。这个线程可能在等待访问某个资源，而且在这个资源访问之前，这个线程无法继续运行。  
所有可运行线程按照优先级保存在池中。当一个被阻塞的线程编程可运行时，它会被放回相应的可运行池。优先级最高的非空池中的线程会得到处理时间。  
因为Java线程不一定是分时的，所以你必须确保你的代码中的线程会不是地给另外一个线程运行的机会。这可以通过各种时间间隔发出sleep()调用来做到。
## 线程的状态和生命周期 ##
* 新建：新创建的线程处于新建状态
* 就绪：在创建线程后，它将处于就绪状态，等待start()方法被调用
* 执行：线程在开始执行时进入运行状态
* 阻塞:在线程等待另一个事件时（例如：输入/输出），就称其处于阻塞状态
* 死亡：在run()方法已完成执行或其stop()方法被调用后，线程就属于死亡的状态
## 后台线程和前台线程 ##
* 对Java来说，只要还有一个前台线程在运行，这个程序就不会结束，如果一个进程中只有后台线程运行，这个进程就会结束
* 前台线程是相对于后台线程来说的，按前面的方式产生的线程是前台线程，如果对某个线程对象在启动（调用start()方法）之前调用了setDaemon(true)方法，这个线程就变成了后台线程。
## 联合线程和join方法 ##
* jion()方法使当前其它的线程停下来等待，直至调用join方法的线程终止
* 让调用join方法的线程执行完毕后，执行该线程
* 把调用join方法的线程合并到当前线程中
## Thread.sleep() ##
* sleep()方法是使线程停止一段时间的方法。在sleep时间间隔期满后，线程不一定立即恢复执行。这是因为在那个时刻，其它线程可能正在运行而且没有被调度为放弃执行，除非：

 * “醒来”线程具有更高的优先级
 * 正在运行的线程因为其它原因而阻塞
* 该方法为静态方法，使执行次语句的线程休眠
## 线程组 ##
* Java定义了在多线程运行系统中的线程组（ThreadGroup）对象，用于实现按照特定功能对线程进行集中式分组管理。用户创建的每个线程均属于某线程组，这个线程组可以在线程创建时指定，也可以不指定线程组以使该线程处于默认的线程组之中。但是，一旦线程加入某线程组，该线程就一直存在于该该线程组中直至线程死亡，不能在中途改变线程所属的线程组。
## 线程的调度和优先级 ##
* Java中的线程优先级是在Thread类中定义的常量
 * MIN_PRIORITY :值为1
 * NORM_PRIORITY:值为5
 * MAX_PRIORITY:值为10
* 缺省优先级为NORM_PRIORITY
* 有关优先级的两个方法有两个:
 * final void setPriority(int newp) 	修改线程当前的优先级
 * final int getPriority()		返回线程的优先级
## 线程运行中信息 ##
* Thread.currentThread()
* getName()
* getThreadGroup()
* getPriority()
* isAlive()
* idDaemon()
## 线程同步的必要性 ##
* 由于线程共享同一进程的内存空间，多个线程需要同时访问同一个数据，对共享数据的并发访问可能产生竞争
* 如果没有正确的保护措施（同步），对共享数据的访问会造成数据不一致的错误
## 同步块 ##
    synchronized(object){	//...	}
* 要钥匙在对象中，而不再代码中
* 每个对象有一个钥匙
* 为了执行synchronized()块，线程需要的到对象中的钥匙。一旦获得了钥匙，对象就不再拥有钥匙
* 如果当线程要执行sychronized()时，钥匙不在对象中，线程就stall了。一直到钥匙还到了对象中，才被这个对象拿到。
* 当线程离开sychronized()块，钥匙就还给了对象
## 怎么保护数据 ##
* synchronized()并不是保护数据不被访问，而是保护同一时刻，只有一个线程正在运行。
 1. 数据私有
 2. 所有的访问都给同步化
 3. 用数据本身做钥匙
## 线程的同步 ##
* 对象锁标志
 *　每个对象都有一个标志，它可以被认为是“锁标志”
 *　synchronized允许和锁标志交互
*　释放锁标志
 * 线程执行到synchronized()代码块末尾时释放
 * synchronized()代码块抛出中断或异常时自动释放锁标志
* synchronized()放在一起
 * 所有对易碎数据的存取都应该同步
 * 由synchronized保护的易碎数据应该是private
## 死锁 ##
* 两个线程相互等待来自对方的锁
* 它不能被检测或避免
* 它可以通过以下方法来避免
 * 决定获取锁的次序
 * 始终遵照这个次序
 * 按照相反的次数释放锁
## Object ##
* 每个对象都有一个线程池，对象可以调用wait方法让对象同步的线程加入到该线程池中，或者调用notify方法让等待的一个线程离开次线程池
* 如果是notifyAll方法，则让该对象的等待池中的对象都离开  
每个对象都包含了一把锁。调用synchronized方法时，对象就会被锁定，不可再调用那个对象的其它任何synchronized方法，除非第一个方法完成了自己的工作，并解除锁定。
* java.lang.Object类提供了两个用于线程通信的方法：wait()和notify()。如果线程对**一个同步对象x发出一个wait()调用，该线程会暂停执行，知道另一个线程对同一个同步对象x发出一个notify()调用**
* 为了让线程对一个对象调用wait()或notify()，线程必须锁定那个特定的对象。也就是说，只能在它们被调用的实例的同步块内使用wait()和notify()。对于这个实例来说，需要一个以synchronized(cab)开始的块开执行cab.wait()和cab.notify()调用


