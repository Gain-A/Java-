# 初始化和清理 #

## 包 ##

### 包的创建 ###
* 缺省状态下为无名包
* 有名包的创建使用package语句

		package packagename;
### 包的引用 ###
* 直接引用：在同一文件下
* 使用包名、类名前缀
 * package1.package2.MyClass;
* 加载引用：使用import语句
 * import package1.package2.MyClass;

## 编译单元 ##
每个编译单元必须是以.java结尾的文件名称，在一个编译单元里，**至多**有一个声明为public的类，这个类的名字必须与文件的名字相同。  
编译一个.java文件，对应于文件中的每一个类，会得到一个.class文件，文件名与类名相同。一个程序时一系列.class文件的有机组合。

## 库 ##
* 在计算机系统中，库是用于开发软件的字程序集合。
* 库和可执行文件的区别是，库不是独立程序，他们是向其它程序提供服务的代码。
### 库的功能 ###
**隐藏实施过程--封装--访问控制**
* 隐藏--包
* 封装--类
* 访问控制--访问控制修饰符
* 每个库的用户（client programmer）必须能依赖自己使用的库，并知道新版本的库推出，自己不需要改写代码
* 库创建者应声明哪些是客户程序员可以使用的，哪些是不可以使用的。

#### 类的访问控制 ####
* 一个编译单元（文件）中只能有一个public的类。因此一个编译单元只有唯一的一个公共界面，其余的类都是"friendly"的。public类的名称必须和文件的名字是一样的
* 尽管很少见，但是可以存在一个编译单元没有public类，所有的类都是"friendly"的，那么文件名可以任意起

## 初始化和清理概念介绍 ##
* 初始化和清理是程序设计安全性的两个最重要的问题
* C++为我们引入了构造函数的概念，Java也沿用了这个概念，但新增了自己的垃圾收集器
* **构造函数可以理解为初始化函数**

### 用构造函数自动初始化 ###
在创建对象的时候，Java会自动调用那个没有参数的构造函数。
* 如果一个类没有定义构造函数，则编译程序会帮我们自动创建一个缺省的构造函数就
* 然而，一旦定义了一个构造函数，则默认构造函数就不存在了
* 构造函数支持**重载**
### this关键字在构造函数中的应用 ###
* this关键字可以为已调用了其方法的那个对象生成相应的句柄
* 在一个构造函数中调用另一个构造函数时，用this关键字
* 构造函数调用是且只能是构造函数中**第一条**语句，并且**不能在一个构造函数中调用两个以上的构造函数**
* this表示调用该方法的那个对象，其使用和其它对象没有不同
* 在方法内部调用同一个类的不同方法，不需要指出this。只有当显式的需要返回该对象的时候才需要，返回当前使用的对象
* this是在类中函数调用其它函数时使用，对象是直接调用对象内部的函数时使用。

## 清理：收尾和垃圾收集 ##
* 垃圾收集机制只知道怎样释放由new分配的内存，所以它不知道如何释放对象的"特殊"内存。一旦垃圾收集机制准备好释放对象占用的存储空间，它首先调用finalize()方法。
* finalize()和C++的析构函数截然不同
 * 垃圾收集不等于析构
 * 对象可能不会被当做垃圾收集掉
 * 垃圾收集只跟内存有关
### 成员初始化 ###
* **简单变量**初始化为默认值
* **引用变量**初始化为null
### 定义初始化 ###
* 一个直接的做法是在定义数据成员的同时也为其赋值  

		class Member{
	    	char c = 'c';
			int i = 50;
		}
* 也可以用相同的方法初始化对象，并给引用变量赋值

	class Member{
		People p = new People();
	}

### 可以调用一个方法进行初始化 ###
* 简单的方法初始化  

		int i = f();
* 方法也可以使用参数
		int i = f();
		int k = g(i);
* 参数不能是尚未声明的其它数据成员(无法通过编译)

		int j = g(i);
		int i = f();
### Java变量初始化顺序 ###

1. 先静态后非静态
2. 先声明后赋值
3. 先属性后方法
4. 先父类后子类
5. 在一个类中，初始化的顺序是由变量在类内的**定义顺序决定的**。即使变量定义大量遍布于方法之间，那些变量仍然会在调用任何方法之前得到初始化——在构造函数之前
#### 静态数据初始化 ####
* 静态的东西属于类
* 类Class和类对象
* 静态数据成员只在这个类的第一个对象要创建的时候初始化
#### final属性初始化 ####
* 如果类的属性为final，则只能赋值一次
* 可以在声明的时候直接赋值
* 可以在构造函数中直接赋值，如果构造方法之间没有调用，则必须在所有的构造函数中都进行初始化
* 上述两种方式，只能选择其中一种

## 引用 ##
* 在Java中除了基本数据类型之外的所有变量都称为引用类型
* 基础数据类型只占用一片内存，可一次定位
* 引用类型占用两块内存，需定位两次
* 类的成员变量在不同的对象中都不同
* 类的方法是共享的，被所有的对象共享，存放在代码区
### 引用赋值 ###
* 当"from one object to another"赋值，实际上是将引用从一个地方赋值到另外一个地方
* 将一个对象传递到方法内部时，也是赋值(引用传递)
### 对象的内存分配 ###
* 原始类型的声明的变量分配存储器空间
 * 默认为基本值
* 非原始类型的声明，只分配**变量的存储空间**，不分配对象存储器空间
 * 默认为null
* 声明的引用变量不是数据本身，而是对象的引用

## 内存区 ##
* 堆栈

		Computer com;
* 堆

		com = new Computer();
* 静态区	
* 代码区


