#接口、内部类、抽象类#

## 接口 ##
* 接口是一种数据类型
* 接口的定义关键字是**interface**
* 接口是**一系列方法和特征的集合**
* 接口中特征的定义是有固定格式的：
 * `public static final 数据类型 变量名 = 值;`
 * ps:`public static final 可以省略`
* 接口中方法的定义也是有固定格式的：
 * `public abstract 返回类型 方法名 ( 参数列表);`
 * ps:`public abstract 可以省略`
 * 方法**一定不能**是`static`的 
 * 因为接口方法是抽象的，所有它不能标识为final、native(指出方法是用于平台相关的语言，如C语言编写)、strictfp(指出表达式浮点数将严格遵守FP限制规则)或synchronized
* 类和类是继承的关系 **is-a**
* 类和接口是实现的关系 **like-a**
* 接口不能直接new对象，但可以声明接口类型的引用,用接口的实现类创建对象
* 定义类实现接口使用**implements**,可以实现多个接口，接口之间用","隔开
* 接口与接口之间是继承关系，并且是可以**多继承**
* 接口能够被多态使用
* **接口不能实现另一个接口和类**
### 接口的实现 ###
在类的声明中使用implements关键字来实现接口，一个类可以实现多个接口，各接口之间用“，”隔开。

* 若实现接口的类不是抽象类，则必须实现接口所有的抽象方法，即为所有的抽象方法定义方法体
* 一个类在实现某个接口的抽象方法时，必须使用完全相同的方法名，参数列表
* 接口的抽象方法的访问控制符已指定为public，所以类在实现的时，必须显示的使用public修饰符，否则警告缩小了接口中定义的访问修饰符范围

### 接口的作用 ###
接口是一种合约，规定了接口可干什么，但是不关心具体的实现过程

* 提高代码的扩展性
* 弥补类单继承的不足

## 内部类 ##
内部类：定义在类的内部

* 定义使用class关键字
* 非静态内部类的创建依赖于外部类对象
 * `Outter.Inner inner = new Outer().new Inner();`
* 非静态内部类可以调用外部类的静态成员、方法和非静态成员、方法
* 静态内部类的创建只依赖于外部类类名
 * `Outter.Inner_Static inner_static = new Outer.Inner_Static();`
* 静态内部类只能调用外部类的静态成员、方法

### 内部类作用 ###
* 辅助外部类，可以隐藏类的实现细节
* 可以访问外部类的所有成员，包括私有成员

### 局部内部类 ###
* 定义在方法中的内部类
* 可以访问外部类中的私有成员，包括静态的和非静态的
* 局部内部类可以访问局部常量，但是不能访问局部变量
 * 原因是局部常量的声明周期可以覆盖局部内部类的声明周期 
 
## 匿名内部类 ##
* 主要针对接口和抽象类不能直接new对象，通过匿名内部类给接口和抽象类的引用赋值
* 匿名内部类创建的对象只能使用一次
* 主要用于事件监听的创建
* 匿名实现类一次只能实现一个接口或者继承一个类，不能同时继承一类和实现一个接口。

## 抽象类 ##
* 声明格式：

		abstract class ClassName{
			...
		}
* 抽象类用abstract修饰
* 抽象类使用的两种情况
 * 不想使用这个类直接创建对象，把这个类定义为抽象类
 * 如果方法的实现没有具体意义，可以定义为抽象方法，相应这个类必须为抽象类
* 抽象方法：
 * ` 访问修饰符 方法返回值 方法名(参数列表)`
* 抽象方法没有方法体
* 抽象类可以有抽象的方法，也可以没有抽象方法
* 抽象类不能直接new对象，但可以声明抽象类的引用
* 抽象类用来派生子类的，用具体子类创建对象
* 抽象类可以实现接口，不必实现接口中的所有抽象方法
* 抽象类可以继承具体类
* final和abstract不能同时使用
* 抽象类可以有多态

### 抽象类的实现 ###
* 依赖继承，只在父类中声明方法，而不是实现，具体行为由子类实现
* 应用父类声明，子类调用
* 实现方式：后期绑定
